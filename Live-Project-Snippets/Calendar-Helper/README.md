The function of the Calendar class is to transform our user/event/schedule data into JSON serialized data we can display on the calendar library FullCalendar.

Our team decided in Scrum that the best implementation route for our Calendar class was a static class, as a helper.

The Calendar needed two basic methods to become functional. Both methods needed to return JSON serialized objects, each of which is an event that FullCalendar can parse and display.

The first method takes a list of Events, one of our model types in the project. I chose to implement this as a generic list, as in practice we're working with objects that inherit from Event (WorkTimeEvent and TimeOffEvent). The method casts the members of the generic list as the super-class Events, using polymorphism to simplify and condense the coding into a single method. The Events are then mapped to an internal class the Calendar method uses to restrict data flow from the model to the JSON serialization, in much the same way that a ViewModel abstracts from a Model. This ensures that no extraneous data moves from the Event to the JSON output, so that we are not exposing potentially sensitive information nor causing trouble in the library receiving unexpected data. Since the input is a list of Events, it is relatively easy to map those Events to the internal class, then serialize that list for return output.

The second method does not take a list of Events, but rather a user Schedule and two DateTime parameters, the start and end dates which we want the method to work within. A Schedule is not a list of Events, but rather a list of WorkPeriods. While WorkPeriods have many similar properties to Events, they are not events, and the Schedule itself has properties outside the list of WorkPeriods, so it requires more work to process than the first case above. The method generates a list of the internal class events and populates them based on the information from the Schedule. The most complicated part of this entire corner of the project was handling this logic.

The controller iterates over the days between the start and end days provided. For each day, it checks whether the schedule has started and checks to be sure it has not ended before creating an internal event. However, a Schedule can be Repeating, which means the set of WorkPeriods occurs again as soon as the current list of WorkPeriods ends. Thus, we have to track our loop carefully, using a schedule index derived from a modulo comparison of the difference between the date being currently checked vs the start day of the schedule, and combining that with a measure of the number of times we've looped through the schedule (derived by dividing the difference between current and schedule start day and dividing that by the length of the Schedule (by counting the number of WorkPeriods).

Once that list is completely populated, it is serialized just as in the first example and returned to the calling method. The goal accomplished by doing that ensures that no matter which form of data is send to the Calendar helper, the return data is essentially the same.
