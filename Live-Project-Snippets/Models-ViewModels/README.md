Our Live Project used an Entity Framework Code-First database to store our user, event, and schedule data. As a result, the initial project creation including some basic, first-pass models and scaffolding, as is easily done when developing an MVC Application in Visual Studio.

Once we got into our Scrum, we realized some of the initial model decisions no longer fit with the needs of our application and our Product Owner. As a result, I made a number of changes to the Schedule and WorkPeriod models and designed the Schedule ViewModel to fit our new needs, as expected in Agile development.

In the models, the biggest changes - and the changes I learned the most from - were decisions about date/time data and nullability.

When I came to the project, the model called for storing date/time data as a string. While such a string can in principle be parsed to find the date fairly easily, the upcoming need for schedule math (see the Calendar helper for more information) made a transition to DateTime data type make more sense. However, in some cases, we might not have DateTimes for all data - for example, an open-ended schedule for a current employee might not have an end date until they depart the company or change shifts. Thus, it was obviously important that we be able to store null values, requiring us to use the nullable 'DateTime?' data type. While this occassionaly requires a bit more code checking to ensure we don't try to do math on null values, it makes the basic math itself much easier, and removed a number of formatting issues with the datepickers we were using throughout the application as it tried to parse the date strings.

The ScheduleViewModel is not too complicated once you know what is available in the Schedule model and what other meta-data we need for the view to work the way we want. Creating a ViewModel, however, was itself very instructive on how and why MVC/MVVM architecture is set up the way it is. Instead of having tightly coupled views and database connections, I could divert, funnel, filter, and control the transfer, ensuring that data I only need to assist the creation of the Schedule object do not need to be actually stored in the database. It was also valuable to create constructors in each of the model and viewmodel so I could easily construct one from the other, and it was a good reminder of the power of overloaded constructors as well, so I could have an 'initial' Schedule ViewModel generate some necessary data without needing to recreate it whenever the ViewModel object was constituted again (as in through Model Binding on the form submission).
